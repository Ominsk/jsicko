jsicko.note.condition.checks=\
  [jsicko] For method {0}: creating {1} checks {2}

jsicko.note.instrumented.class=\
  [jsicko] Code of instrumented class {0}: \n\t {1}

jsicko.note.instrumented.method=\
  [jsicko] Code of instrumented method {0}: \n\t {1}

jsicko.note.contract.interfaces=\
  [jsicko] Contract interfaces for {0}: {1}

jsicko.note.overridden.old.method=\
  [jsicko] Code of overridden old method {0}

jsicko.err.missing.clause=\
  [jsicko] Missing {0}

jsicko.err.returns.on.void.method=\
  [jsicko] Use of returns param on void method for {0}

jsicko.err.returns.on.precondition=\
  [jsicko] Use of returns param on precondition for {0}

jsicko.err.raises.on.precondition=\
  [jsicko] Use of raises param on precondition for {0}

jsicko.err.missing.param.name=\
    [jsicko] Missing param name {0} for {1}

jsicko.err.wrong.param.type=\
    [jsicko] Wrong type {2} for param {0}, expected type compatible with {1} in {3}

jsicko.err.invariant.non.zero.arity=\
  [jsicko] Invariant {0} has parameters, should have none.

jsicko.err.invariant.is.static=\
  [jsicko] Invariant {0} is static, should be an instance method.

jsicko.err.invariant.is.not.boolean=\
  [jsicko] Invariant {0} return type is not boolean, declared as {1}.

jsicko.err.clause.is.not.boolean=\
  [jsicko] For clause {0}, found method {1} whose return type is not boolean, but {2}.

jsicko.err.incompatible.clause=\
  [jsicko] {0} clause {1} is not compatible with {2} method {3}.